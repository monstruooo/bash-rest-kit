#!/bin/bash

info='
	dyn_api is both function that runs curl and the url of the api

	http://dyn.com/blog/dynect-api-example-curl-managed-dns-aws-heroku-devops/
	DynECT Managed DNS API: Get Started Using CURL, Java or Python'

export dyn_api=https://api.dynect.net

function dyn_cfg () {
[[ -z $dyn_customer ]] && read -p 'Customer: ' dyn_customer
[[ -z $dyn_user ]] && read -p 'User: ' dyn_user
[[ -z $dyn_pwd ]] && { read -s -p 'Password: ' dyn_pwd ; read_nl ; }
}

function dyn_token_get () {
if [[ -n $dyn_token ]] ; then
	(( $(date +%s) - ${dyn_token_ts:-0} < 300 )) && return 0
	dyn_token_revive && { export dyn_token_ts=$(date +%s) ; return 0 ; }
fi
local data=$( jq -n '.customer_name="'$dyn_customer'" |
.user_name="'${dyn_user}'" | 
.password="'${dyn_pwd}'"' )
res=$(curl -Ss -H content-type:application/json --data "$data" -X POST $dyn_api/REST/Session)
dyn_token=$( echo $res | jq -e -r .data.token ) && export dyn_token dyn_token_ts=$(date +%s) 
# function returns error if jq fails
}

function dyn_token_kill () {
# destroy token
[[ -n $dyn_token ]] || return
curl -Ss -H content-type:application/json -H Auth-Token:\ $dyn_token -X DELETE $dyn_api/REST/Session |
jq -e -r .status 2>/dev/zero | egrep -q success && unset dyn_token 	
}

function dyn_token_revive () {
[[ -n $dyn_token ]] || return
curl -Ss -H content-type:application/json -H Auth-Token:\ $dyn_token -X PUT $dyn_api/REST/Session |
jq -e -r .status 2>/dev/zero | egrep -q success 	
}

function dyn_api () {
dyn_token_get
local exit_code
res=$( curl -Ss -H content-type:application/json -H Auth-Token:\ $dyn_token "$@" 2>&1)
exit_code=$?
if [[ x$exit_code != x0 ]] ; then
	echo Curl error mesg: $res 1>&2
	echo Curl error code: $exit_code 1>&2
	return $exit_code
fi	
# set +x ; echo 
# login: There was a problem with your credentials
if echo $res | jq -e -r .status 2>/dev/zero | egrep -q success ; then
	if [[ x$dyn_debug =~ x[Oo][Nn] ]] ; then
		echo $res | jq -c 
	else
		echo $res |
		jq -e '{ function: "'${FUNCNAME[0]}'" , msgs: [.msgs[].INFO]  , data }'
	fi
	return 0
elif echo $res | fgrep -q '<html>' ; then
	echo $res | lynx -dump --stdin 1>&2 || echo $res 1>&2
	return 1
elif echo $res | is_json ; then
	if [[ x$dyn_debug =~ x[Oo][Nn] ]] ; then
		echo $res | jq -c 1>&2
	else
		echo $res | jq -e -r '{ function: "'${FUNCNAME[0]}'" , msgs: [.msgs[].INFO] }' | egrep --color '.*' 1>&2
		return 1
	fi
fi
}

function dyn_publish () {
local info='
	Checking for pending changes
	dyn_api $dyn_api/REST/ZoneChanges/$domain | jq'
[[ -n $2 ]] && local domain=$2 || return 1
if [[ $1 == zone ]] ; then
	# to publish new zone
	dyn_api -X PUT --data '{"publish":true,"zone":"'$domain'"}' $dyn_api/REST/Zone/$domain/ 
elif [[ $1 == changes ]] ; then
	dyn api -X PUT --data '{"publish":true}' $dyn_api/REST/Zone/$domain/
fi | jq '{function: "'${FUNCNAME[0]}'" , msgs }'
}

dyn_domain_ls ()
{
if [[ -z $1 ]] ; then
	dyn_api $dyn_api/REST/Zone/ | jq -r .data[] | cut -d/ -f4
	return
fi

local domain=$1 id name type

{ echo -e "Id \t Name \t Type" ;
dyn_api $dyn_api/REST/AllRecord/$domain/ | jq '{data}' |
jq -r .data[] |
cut -d / --output-delimiter=\  -f 3,5,6 |
while read type name id ; do
	type=${type%Record}
	[[ $type =~ SOA|NS ]] && continue
	[[ $name =~ ^$domain$ ]] && name=@
	[[ $name =~ .+$domain$ ]] && name=${name%.$domain}
	echo -e "$id \t $name \t $type"
done ; } | tabs2cols 
}

function dyn_record2table () {
# jq .data.rdata | jq --stream -j  'select((.[1]|type)=="number") | .[0][],"=",.[1],"," '
# jq -j '.data.rdata | (keys[] as $k | $k, "=", .[$k],","),"\n" '
cat /dev/stdin | 
jq -c -j ' .data |

.value = (.rdata | .. | strings) |

.rdata = [ ( 
		.rdata | keys[] as $k |
		if .[$k]|type=="number" 
		then 
			$k + "=" + ( .[$k] | tostring ) 
		else
			empty 
		end
		) ] |

if .rdata | length == 0 then .rdata="-" else .rdata=( .rdata | join(",") ) end |

.zone , " " , .record_id , " " , .fqdn , " " , .record_type , " " , (.ttl|tostring) , " " , .rdata , " " , .value ,
"\n" ' | while 
read domain id name type ttl rdata value ; do
	[[ $name == $domain ]] && name=@ || name=${name%.$domain}
	echo -e "$id \t $name \t $type \t $ttl \t $rdata \t $value"
done 
}

function dyn_record_ls () {
local domain ids 
if [[ -z $2 ]] ; then
	cat << EOF 1>&2
Usage: <command> <domain> all
       <command> <domain> naked
       <command> <domain> <record1 id> <record2 id> ...
EOF
	return 1
fi
domain=$1
shift

local domain_ls=$(dyn_ls_domain $domain) ids 
if [[ $1 == all ]] ; then
	ids=$(dyn ls $domain | egrep -o '^[0-9]+')
else 
	ids=$( echo "$domain_ls" | egrep "$1" | egrep -o '^[0-9]+')
fi

local id name type cache
for id in $ids ; do
	local name type
	read id name type < <(echo "$domain_ls" | awk '{if ($1 == "'$id'" ) print }')
	[[ -z $name ]] && continue 
	[[ $name == @ ]] && name=$domain || name=${name}.$domain

	local cache=$dyn_domains_dir/${domain}.$id
	export cache
	[[ x$dyn_use_cache =~ x[Oo][Nn] ]] && jq -e -r .status $cache 2>/dev/zero | egrep -q success
	local exit_code=$?
	if [[ x$exit_code == x0 ]] ; then
		continue
	fi

	# start background subshell 
	( 
	unset dyn_token # Every background request should have its own token/session to avoid rate limit
	dyn_api https://api.dynect.net/REST/${type}Record/${domain}/${name}/${id} > $cache || rm -f $cache
	dyn token kill
	)& 
	# end subshell

	sleep .02
done | cat
wait
{ echo -e "Id \t Name \t Type \t TTL \t Rdata \t Target/Value" ;
for id in $ids ; do
	cache=$dyn_domains_dir/${domain}.$id
	jq -e . $cache || return
done | dyn_record2table ; } | tabs2cols
}

function dyn_ls () {
if [[ -n $2 ]] ; then
	dyn_record_ls $@
elif [[ $1 == cache ]] ; then
	fgrep -l  '"rdata"' /dev/shm/oskars/dyn/domains/* | sort
else
	dyn_domain_ls $@
fi
}

function dyn_debug () {
[[ x$dyn_debug =~ x[Oo][Nn] ]] && echo $*
}

function dyn_tmpfile () {
	echo $dyn_work_dir/${FUNCNAME[1]}.$BASHPID
}

function dyn () {

# export dyn_debug=off
# export dyn_use_cache=on
dyn_work_dir=/dev/shm/$USER/dyn
dyn_domains_dir=$dyn_work_dir/domains
dyn_work_dir=$dyn_work_dir/run
export dyn_domains_dir dyn_work_dir  
mkdir -p $dyn_work_dir $dyn_domains_dir

dyn_cfg

local action=$1
shift
case x$action in
	xdomain|xrecord|xcache|xtoken)
		action=${action}_$1
		shift
		dyn_$action "$@" 
		# dyn ll cache -> dyn_ll_cache
		# dyn domain rm 12345 -> dyn_domain_rm 12345
		;;
	x)
		;;
	*)
		dyn_$action "$@" 
		# dyn ll -> dyn_ll
		# dyn ll 12345 -> dyn_ll 12345
		;;
esac	
} # end function dyn
