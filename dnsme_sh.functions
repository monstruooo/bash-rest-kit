#!/bin/bash

function dnsme_api () {

local api_url=https://api.dnsmadeeasy.com
[[ x$sandbox == x1 ]] && api_url=https://api.sandbox.dnsmadeeasy.com

dnsme_throttle # Checking that the request rate is not exceeded

request_date=$(
{ echo -n "$(date -u -R) " ; date -u +%Z ; } | cut -s -d' ' -f1-5,7
)

hmac=$(echo -n "$request_date" | openssl sha1 -hmac "$dnsme_secret_key" | sed 's/.*= //g')

# http headers
api_key_H="x-dnsme-apiKey:$dnsme_api_key"
hmac_H="x-dnsme-hmac:$hmac"
req_date_H="x-dnsme-requestDate:$request_date"
content_type_H="content-type:application/json"
accept_type_H="accept:application/json"
local api_uri=$1
shift
api_uri=${api_uri#*dnsmadeeasy.com/} # backward compatibility for calls that use full url instead of uri

local src args msgs
args=$(echo $api_uri $* | jq -R .)
src=$(echo ${FUNCNAME[*]} | cut -d \  -f 1-10)
if ! res=$(curl -k -s -S -H "$api_key_H" -H "$hmac_H" -H "$req_date_H" -H "$content_type_H" -H "$accept_type_H" $api_url/$api_uri "$@" 2>&1 )
then
	exit_code=$(( $? + 10 ))
	args2json res=$exit_code src="$src" args="$args" msgs="Curl failed: $res" | jq . | api_err
	return $exit_code
fi

if [[ -z $res ]] ; then
	res=$(args2json src="$src" msgs="Sucess. No curl output")
	return 0
fi

# For some reason dnsme returns errors as jq filter instead of json	
if jq -n -e "$(echo $res | cut -c 1-333) | .error"  >/dev/zero 2>&1 ; then
local logic='
	Reconstructing error can save you a lot of time troubleshooting'
	args2json res=1 src="$src" args="$args" msgs="$res" | jq . | api_err
	return 1
fi

if ! echo $res | is_json ; then 
	args2json code=2 src="$src" args="$args" msgs="Request failed. Response is not json" | jq . | api_err
local logic='
	if response is not json. DNSME returns web pages on some errors'
    { echo $res | grep -q '<html>' && echo $res | lynx -dump --stdin 1>&2 || echo $res ; } | api_err
    return 2
fi

} # end function

function dnsme_throttle () {
local LIMIT=150 FRAME=5 # Request limit is 150 per 5 min

# local reqs=$(ls $dnsme_work_dir/req_ts.* -1r)
local reqs=$(find  $dnsme_work_dir -name req_ts* | sort -r)
if (( $(echo "$reqs" | wc -l ) < 150 )) ; then
	touch $dnsme_work_dir/req_ts.$(date +%s)
	return 0
fi

local start=$(echo "$reqs" | sed -n 149p | egrep -o [0-9]+$)
local frame_end=$(( start + FRAME*60 ))
if (( frame_end > $(date +%s) )) ; then
	local secs_wait=$(( frame_end - $(date +%s) ))
	args2json src=${FUNCNAME[0]} msg="Rate limit exceeded. Waiting $secs_wait seconds" time="$(date)" | jq . 1>&2
	sleep $secs_wait
	echo "$reqs" | sed '1,149d' | xargs rm -f
fi
touch $dnsme_work_dir/req_ts.$(date +%s)
}

function dnsme_domain_status () {
	local domain=$1 id
	[[ -n $domain ]] || return 255
	if [[ x$domain =~ ^x[0-9]+$ ]] ; then
		dnsme api V2.0/dns/managed/$domain
	else
		dnsme api V2.0/dns/managed/id/$domain
	fi || return
	echo $res | json2bash
} # end function
	
function dnsme_domain_id () {
	res=$(cat $dnsme_cache | 
	jq -e --arg domain $1 '.data[] | select(.name==$domain or (.id|tostring)==$domain)| {id,updated,name}')

	if ! [[ x$? == x0 ]] ; then
		args2json src=$FUNCNAME msgs="Domain $1 not found" | jq . | api_err
		return 1
	fi
	echo $res | json2table
}

function dnsme_purge () {
# purge deleted domains
local domains cached_domains
domains=$( dnsme ls | awk '{print $3}' | sed 1d )
cached_domains=$( find $dnsme_domains_dir/* | egrep -v 'dnsme.domains')
diff -Bb  <( echo "$domains")  <(echo "$cached_domains")  --suppress-common-lines  |
egrep '^>' | awk '{print $2}' | xargs -L 1 /bin/rm -fv
}

function dnsme_cfg () {
[[ x$1 == set ]] && unset dnsme_api_key dnsme_secret_key
[[ -z $dnsme_api_key ]] && read -p 'API Key: ' dnsme_api_key
[[ -z $dnsme_secret_key ]] && read -s -p 'API Secret Key: ' dnsme_secret_key
} # end function dnsme_configure

function dnsme_url () {
local domain_id=$1
echo https://cp.dnsmadeeasy.com/dns/managed/$domain_id
}

function dnsme_updatedb () {
if [[ -z $1 ]] ; then
	dnsme_api V2.0/dns/managed && echo $res > $dnsme_cache
	# Will return with error of dnsme_api, if dnsme_api fails
fi

local name serial id
read id serial name < <(dnsme domain id $1)
[[ x$id =~ ^x[0-9]+$ ]] || return 1
local domain_cache=$dnsme_domains_dir/$name
dnsme_api V2.0/dns/managed/$id/records && echo $res > $domain_cache
}

function dnsme_ls () {

if [[ -z $1 || x$1 == xdomains ]] ; then  
	if ! cat $dnsme_cache | is_json ; then
		dnsme updatedb
	fi
	res=$(<$dnsme_cache)
	echo $res |
	{ 
	to_array "Domain Id" Serial "Domain name" ;
	jq -r ' .data | sort_by("name") | .[] | 
	{ id , updated, name }' ;
	} | json2table

	return
fi

if [[ x$1 == xcache ]] ; then
	grep -l 'type' $dnsme_domains_dir/*
	return
fi

local domain serial id
domain=$1
shift
read id serial domain < <(dnsme domain id $domain)
[[ x$id =~ ^x[0-9]+$ ]] || return 1
local domain_cache=$dnsme_domains_dir/$domain
if ! cat $domain_cache | is_json ; then
	dnsme updatedb $domain
fi
res=$(<$domain_cache)
echo $res |
if [[ -z $1 ]] ; then  
	{
	to_array Id Name Type TTL Rdata Value ;
	# The next jq take input from the pipe
	jq -r '.data | sort_by(.type) | .[] |
	if .name == "" then .name="@" else . end |
	{ id , name, type, ttl,
	rdata: (
	{weight,priority,port,mxLevel} | 
	[ to_entries[] |
	if .value|type=="number" then .key + "=" + (.value|tostring) else empty end ] | 
	if length > 0 then join(",") else "-" end
	),
	value }' ; 
	} | json2table
else
	jq -c '.data[]|select((.id|tostring)=="'$1'")' | json2bash
fi
} # end function 

function dnsme () {

# export dnsme_debug=off

dnsme_work_dir=/dev/shm/$USER/dnsme
dnsme_domains_dir=/dev/shm/$USER/dnsme/domains
dnsme_cache=$dnsme_domains_dir/dnsme.domains
dnsme_work_dir=$dnsme_work_dir/run
mkdir -p $dnsme_work_dir $dnsme_domains_dir

dnsme_cfg

local action=$1
shift
case x$action in
	xdomain|xrecord|xcache)
		action=${action}_$1
		shift
		dnsme_$action "$@" 
		# dnsme ls cache -> dnsme_ls_cache
		# dnsme domain rm 12345 -> dnsme_domain_rm 12345
	;;
	*)
		dnsme_$action "$@" 
		# dnsme ls -> dnsme_ls
		# dnsme ls 12345 -> dnsme_ls 12345
	;;
esac	
} # end function dnsme
