#!/bin/bash

DNSME_TMP_DIR=/dev/shm/$USER/tmp/dnsme
mkdir -p $DNSME_TMP_DIR

function dnsme_cfg () {
[[ x$1 == set ]] && unset dnsme_api_key dnsme_secret_key
[[ -z $dnsme_api_key ]] && read -p 'API Key: ' dnsme_api_key
[[ -z $dnsme_secret_key ]] && read -s -p 'API Secret Key: ' dnsme_secret_key
} # end function dnsme_configure

function dnsme_record_to_cols_bak () {
while read -r line ; do
    echo "$line" | jq -c -r '.data | sort_by(.type) | .[] |
	"\(.id) \( if .name == "" then "@" else .name end) \(.type) \(.ttl)  \(.value)"' |
	printf '%-11s %-44s %-11s %-8s %s'
	echo 
done
} # end function

function dnsme_record_to_cols () {
local flow='
	{ echo ... ; cat ... | jq ... ; } | awk ...
	{      ... ;              ... ; } groups output of all commands for pipe'

{ echo -e "Id\tName\tType\tTTL\tValue" ;

/bin/cat /dev/stdin |
jq -r '.data | sort_by(.type) | .[] |
(.id|tostring) + "\t" + (if .name == "" then "@" else .name end) + "\t" + .type + "\t" + (.ttl|tostring) + "\t" + .value' ; } |
awk -F"\t" '{printf "%-11s %-44s %-11s %-8s %s\n",$1,$2,$3,$4,$5}'
} # end function


function dnsme_api () {

local dnsme_url=https://api.dnsmadeeasy.com
[[ x$sandbox == x1 ]] && dnsme_url=https://api.sandbox.dnsmadeeasy.com

dnsme_throttle # Checking that the request rate is not exceeded

request_date=$(
{ echo -n "$(date -u -R) " ; date -u +%Z ; } | cut -s -d' ' -f1-5,7
)

hmac=$(echo -n "$request_date" | openssl sha1 -hmac "$dnsme_secret_key" | sed 's/.*= //g')

# http headers
api_key_H="x-dnsme-apiKey:$dnsme_api_key"
hmac_H="x-dnsme-hmac:$hmac"
req_date_H="x-dnsme-requestDate:$request_date"
content_type_H="content-type:application/json"
accept_type_H="accept:application/json"
local api_uri=$1
shift
api_uri=${api_uri#*/dns/managed/} # backward compatibility for calls that use full url instead of uri

local res=$DNSME_TMP_DIR/res
curl -k -s -S -H "$api_key_H" -H "$hmac_H" -H "$req_date_H" -H "$content_type_H" -H "$accept_type_H" $dnsme_url/V2.0/dns/managed/$api_uri "$@" >$res 2>&1 ||
{ code=$? ; jqres code=$code src=${FUNCMAME[0]} msg="Curl failed: $(<$res)" 2>&1 ; return $code ; }

if [[ -e $res && ! -s $res ]] ; then
local logic ='If no response file or empty'
	jq -n '{ res: { code: 0, message: "No Output. No curl errors either" , source: "Oskar" } }'
	return 0
elif ! is_json $res ; then jqres code=1 source=${FUNCNAME[0]} msg="DNSME Request failed" 1>&2
local logic='if response is not json. DNSME returns web pages on some errors'
    grep -q '<html>' $res && /bin/cat $res | lynx -dump --stdin 1>&2 || /bin/cat $res 1>&2
    return 1
fi
	
if has_key error $res ; then
local logic='
	Reconstructing error can save you a lot of time troubleshooting'
	/bin/cat $res | jq -e ' . | .error | { error: . }'  1>&2 
else
	/bin/cat $res | jq . 
fi
} # end dnsme_api

function dnsme_throttle () {
local FRAME=5 local LIMIT=150 # Request limit is 150 per 5 min
dnsme_req_times="$(date +%s) $(echo $dnsme_req_times | cut -d' ' -f 1-149)"
local debug="dnsme_req_times: $dnsme_req_times"
local count=$(echo $dnsme_req_times| wc -w)
(( count < 150 )) && return 0
local start=$(echo $dnsme_req_times | cut -d' ' -f 150)
local frame_end=$(( start + FRAME*60 ))
if (( frame_end > $(date +%s) )) ; then
	local secs_wait=$(( frame_end - $(date +%s) ))
	jqres code=0 src=${FUNCNAME[0]} msg="Rate limit exceeded. Waiting $secs_wait seconds" time="$(date)" 1>&2
	sleep $secs_wait
else
	return 0 
fi
}

function dnsme_get () {
local readme='
	If no argument is provided the function exits after pulling the list of domains
' # end readme=

local cache=$DNSME_TMP_DIR/all.domains
mkdir -p $( dirname $cache)
logic='( if cache not json or ( refresh set and cache is older than refresh), then refresh cache
Also means: if cache is json and refresh unset, then dont refresh cache'
if ! is_json $cache || ( [[ -n $dnsme_autorefresh ]] && find $cache -mmin +${dnsme_autorefresh:-0} 2>/dev/zero | egrep -q [a-z]+ )
then
	# echo Updating DNSME domain cache 1>&2
	dnsme_api http://api.dnsmadeeasy.com/V2.0/dns/managed/ > $cache
fi

if [[ -z $1 ]] ; then
	/bin/cat $cache | jq .
	return
fi

local dmn_cache=$DNSME_TMP_DIR/$1
readme='if exists and json and not older than autorefresh'
if is_json $dmn_cache  && ( [[ -n $dnsme_autorefresh ]] && find $dmn_cache -mmin -${dnsme_autorefresh:-0} 2>/dev/zero | egrep -q [a-z]+ ) ; then
	/bin/cat $dmn_cache | jq .
	return
fi

local id
id=$(/bin/cat $cache | jq -r -e '.data[] | select(.name=="'$1'" or (.id|tostring)=="'$1'") | .id') ||
	{ jqres code=1 src=${FUNCNAME[0]} msg="Domain $1 id not found" 1>&2 ; return 1 ; }
# id=$(dnsme_domain_id $1) || { jq -n '{ res: { code: 1, source: "'${FUNCNAME[0]}'", msg: "Domain "'$1'" id not found"} }' ; return 1 ; }
# echo Updating domain $1 cache 1>&2
dnsme_api $id/records  > $dmn_cache
/bin/cat $dmn_cache | jq .
} # end function dnsme_get

function dnsme_domains_list () {
info='Backward Compatibility'
# dnsme_api  http://api.dnsmadeeasy.com/V2.0/dns/managed/  | jq --raw-output .data[].name
dnsme_get  | jq --raw-output .data[].name

}

function dnsme_domain_id () { local domain_name=$1 domain_id
    dnsme_get | jq -e -r '.data[] | select((.name=="'$1'") or (.id|tostring=="'$1'")) | .id'
} # end function

function dnsme_domain_id_from_name () {
readme="dnsme_cat backward compatibility"
	dnsme_domain_id "$@"
}

function dnsme_domain_rm () {
local id
args_to_vars "$@"
dnsme_api $id -X DELETE -d "[$id]"
}

function dnsme_record_rm () {
local domain domain_id id 
args_to_vars "$@"
domain_id=$(dnsme_domain_id $domain) || return 1
[[ -z $id ]] || return 2
dnsme_api $domain_id/records/$id -X DELETE
}

function dnsme_configure_record () {
info='provided for backward compatibility'
domain=${1:-None}
shift
name=${1:-None}
shift 
type=$1
shift
value="$*"
dnsme_record_mk domain=$domain name=$name type=$type value="$value"
} # function dnsme_configure_record

function dnsme_domain_mk () {
local domain json data
args_to_vars "$@"
data=$(args_to_json "$@")
if [[  -n $domain ]] ; then
	data=$( jq -n "$data | { name: .domain }")
    dnsme_api https://api.dnsmadeeasy.com/V2.0/dns/managed/ -X POST -d "$data"
	if [[ $?==0 ]] ; then dnsme_autoupdate && dnsme updatedb; fi
	return
else
	return 1
fi
}

function dnsme_record_mk () {
local domain id name type value ttl json data
args_to_vars "$@"
data=$(args_to_json "$@")

data=$( echo "$data" | jq 'if .name=="@" then .name="" else . end')
name=${name/@/}

local domain_id
domain_id=$( dnsme_domain_id $domain) || return 1
data=$( jq -n "$data | del(.domain)")

if [[ -z $ttl ]] ; then
	ttl=1800
	data=$( jq -n "$data | .ttl=$ttl")
fi

local res record_count
flow='If no id and not naked record'
if [[ -z $id && ! x$name == x ]] ; then
	res=$(dnsme_get $domain |
	jq '.data[] | select(.name=="'$name'")' |
	jq -s '{ data: . }') # end res=$(

	if ! record_count=$( jq -e -n -r "$res | .data | length" 2>/dev/zero) ; then
		jqres code=1 src=${FUNCNAME[0]} msg="Something is wrong. Can not count records" 1>&2 
		return 1
	fi

	if (( record_count == 0 )) ; then
		info="Do nothing. Record id is already unset"
	elif (( record_count == 1 )) ; then
   		id=$( $jq -r -n "$res | .data[0].id")
	elif (( record_count > 1 )) ; then
   		jqres code=1 src=${FUNCNAME[0]} msg="$record_count identical records \"$name\" with value $value"
   		return 1
	fi
fi

# Adding/updating records.
if [[ -n $id ]] ; then
    local old_value=$( dnsme_get $domain | $jq -r ".data[] | select(.id==$id) | .value" )
    local data=$(jq -n "$data | .id=$id")
    jqres src=${FUNCNAME[0]} msg="Updating record. No output expected on success" name=$name value=$value old_value=$old_value
    dnsme_api $domain_id/records/$id -X PUT -d "$data" | jq
else
    dnsme_api $domain_id/records/ -X POST -d "$data" | jq
fi
} # function dnsme_mk

function dnsme_records_print () { local domain="$1" json
info='Provided for backward compatibility'

shift
if is_json "$domain" ; then
    json="$domain"
    domain=$(jq -e -n -r "$json | .domain") || return 255
    type=$(jq -e -n -r "$json | .type") && dnsme_args="type=$type&"
    name=$(jq -e -n -r "$json | .name") && dnsme_args="$dnsme_args&recordName=${name}&"
else
    if [[ -n $1 ]] ; then
        [[ -x$name == x@ ]] && unset name
        dnsme_args="recordName=${name}&"
    fi
    shift
    [[ -z $1 ]] && dnsme_args="type=$type&$dnsme_args"
fi
domain_id=$(dnsme_domain_id_from_name ${domain:-None}) || return 1

local dnsme_args name type
ReadMe='
recordName=& returns naked records
recordName=""& is like recordName=* or All records
'
# dnsme_api http://api.dnsmadeeasy.com/V2.0/dns/managed/$domain_id/records?recordName=${record_name}'&'type=$record_type
dnsme_api https://api.dnsmadeeasy.com/V2.0/dns/managed/$domain_id/records"?${dnsme_args}" |
$jq -r '.data | sort_by(.type) | { data: . }'
} # end function

function prn_dns_record () {
local info='Backward Compatibility'
local name=$1 type=$2
shift ; shift 
local value=$*
printf "\t%-33s %-11s %-33s\n" $name $type "$value"
} # end function
