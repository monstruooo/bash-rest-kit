#!/bin/bash

info='
	dyn_api is both function that runs curl and the url of the api

	http://dyn.com/blog/dynect-api-example-curl-managed-dns-aws-heroku-devops/
	DynECT Managed DNS API: Get Started Using CURL, Java or Python'

export dyn_api=https://api.dynect.net

function dyn_api_path () {
local domain id name type fqdn
args2vars "$@" || return 1
[[ -n $domain ]] || return 1
if [[ -z $type ]] ; then
	echo $dyn_api/REST/Zone/$domain
	return
fi

[[ -n $name ]] || return 2
if [[ x$name == x@ ]] ; then
	fqdn=$domain
fi

if [[ $name =~ ${domain}$ ]] ; then
	fqdn=$name
else
	fqdn=${name}.$domain 
fi
	
if [[ -n $id ]] ; then
	echo $dyn_api/REST/${type}Record/${domain}/${fqdn}/${id}
else
	echo $dyn_api/REST/${type}Record/${domain}/${fqdn}
fi	
}

function dyn_cfg () {
[[ -z $dyn_customer ]] && read -p 'Customer: ' dyn_customer
[[ -z $dyn_user ]] && read -p 'User: ' dyn_user
[[ -z $dyn_pwd ]] && { read -s -p 'Password: ' dyn_pwd ; read_nl ; }
}

function dyn_token_get () {
if [[ -n $dyn_token ]] ; then
	(( $(date +%s) - ${dyn_token_ts:-0} < 300 )) && return 0
	dyn_token_revive && { export dyn_token_ts=$(date +%s) ; return 0 ; }
fi
local data=$( jq -n '.customer_name="'$dyn_customer'" |
.user_name="'${dyn_user}'" | 
.password="'${dyn_pwd}'"' )
res=$(curl -Ss -H content-type:application/json --data "$data" -X POST $dyn_api/REST/Session)
dyn_token=$( echo $res | jq -e -r .data.token ) && export dyn_token dyn_token_ts=$(date +%s) 
# function returns error if jq fails
}

function dyn_token_kill () {
# destroy token
[[ -n $dyn_token ]] || return
local res
curl -Ss -H content-type:application/json -H Auth-Token:\ $dyn_token -X DELETE $dyn_api/REST/Session >/dev/zero
unset dyn_token 	
}

function dyn_token_revive () {
[[ -n $dyn_token ]] || return
curl -Ss -H content-type:application/json -H Auth-Token:\ $dyn_token -X PUT $dyn_api/REST/Session |
jq -e -r .status 2>/dev/zero | egrep -q success 	
}

function dyn_api () {
dyn_token_get
local exit_code args msgs
args=$(echo $* | jq -R .)
res=$( curl -Ss -H content-type:application/json -H Auth-Token:\ $dyn_token "$@" 2>&1)
exit_code=$?
if [[ x$exit_code != x0 ]] ; then
	(( exit_code = exit_code + 10 ))
	msgs=$(echo $res | jq -R .)
	jq -n '{ function: "'$FUNCNAME[0]'" ,args: '$args', msgs: '$msgs' }' | egrep --color '.*' 1>&2
	return $exit_code
fi	
# set +x ; echo 
# login: There was a problem with your credentials

if ! echo $res | is_json ; then
	if echo $res | fgrep -q '<html>' ; then
		res=$(echo $res | lynx -dump --stdin 2>/dev/zero || echo $res )
	fi
	echo $res | egrep --color '.*' 1>&2
	return 2
fi

local debug="
$(echo $res | jq .)" # for debugging purposes

if echo $res | jq -e -r .status 2>/dev/zero | egrep -q success ; then	
	return 0
else
	echo $res | dyn_msg | jq -e ".args=$args" | egrep --color '.*' 1>&2
	return 1
fi

}

function dyn_msg () { # to print messages of success for functions like publish or record create
	cat /dev/stdin | jq -e '{ function: "'${FUNCNAME[1]}'", msgs: [.msgs[].INFO] }'
}

function dyn_publish () {
local info='
	Checking for pending changes
	dyn_api $dyn_api/REST/ZoneChanges/$domain | jq'
[[ -n $2 ]] && local domain=$2 || return 3
if [[ $1 == zone ]] ; then
	# to publish new zone
	dyn_api -X PUT --data '{"publish":true,"zone":"'$domain'"}' $dyn_api/REST/Zone/$domain/ 
elif [[ $1 == changes ]] ; then
	dyn api -X PUT --data '{"publish":true}' $dyn_api/REST/Zone/$domain/
fi && echo $res | dyn_msg 1>&2
}

dyn_domain_ls () {
local dyn_token
if [[ -z $1 ]] ; then
	dyn_api $dyn_api/REST/Zone/ 
	echo $res | jq -r .data[] | cut -d/ -f4
	dyn_token_kill
	return
fi

local domain=$1 id name type

{ echo -e "Id \t Name \t Type" ;
dyn_api $dyn_api/REST/AllRecord/$domain/ 
dyn token kill
echo $res | jq '{data}' |
jq -r .data[] |
cut -d / --output-delimiter=\  -f 3,5,6 |
while read type name id ; do
	type=${type%Record}
	[[ $type =~ SOA|NS ]] && continue
	[[ $name =~ ^$domain$ ]] && name=@
	[[ $name =~ .+$domain$ ]] && name=${name%.$domain}
	echo -e "$id \t $name \t $type"
done ; } | tabs2cols 
}

function dyn_record2table () {
# jq .data.rdata | jq --stream -j  'select((.[1]|type)=="number") | .[0][],"=",.[1],"," '
# jq -j '.data.rdata | (keys[] as $k | $k, "=", .[$k],","),"\n" '
cat /dev/stdin | 
jq -c -j ' .data |

.value = (.rdata | .. | strings) |

.rdata = [ ( 
		.rdata | keys[] as $k |
		if .[$k]|type=="number" 
		then 
			$k + "=" + ( .[$k] | tostring ) 
		else
			empty 
		end
		) ] |

if .rdata | length == 0 then .rdata="-" else .rdata=( .rdata | join(",") ) end |

.zone , " " , .record_id , " " , .fqdn , " " , .record_type , " " , (.ttl|tostring) , " " , .rdata , " " , .value ,
"\n" ' | while 
read domain id name type ttl rdata value ; do
	[[ $name == $domain ]] && name=@ || name=${name%.$domain}
	echo -e "$id \t $name \t $type \t $ttl \t $rdata \t $value"
done 
}

function dyn_record_ls () {
local domain ids 
if [[ -z $2 ]] ; then
	cat << EOF 1>&2
Usage: <command> <domain> all
       <command> <domain> naked
       <command> <domain> <record1 id> <record2 id> ...
EOF
	return 1
fi
domain=$1
shift


local domain_ls=$(dyn_domain_ls $domain) ids 
ids=$( echo "$domain_ls" |
if [[ $1 == all ]] ; then
	egrep -o '^[0-9]+'
else 
	egrep "$1" | egrep -o '^[0-9]+'
fi)

local id name type cache
for id in $ids ; do
	local name type
	read id name type < <(echo "$domain_ls" | awk '{if ($1 == "'$id'" ) print }')
	[[ -z $name ]] && continue 
	[[ $name == @ ]] && name=$domain || name=${name}.$domain

	local cache=$dyn_domains_dir/${domain}.$id
	export cache
	[[ x$dyn_use_cache =~ x[Oo][Nn] ]] && jq -e -r .status $cache 2>/dev/zero | egrep -q success
	local exit_code=$?
	if [[ x$exit_code == x0 ]] ; then
		continue
	fi

	( 
	dyn debug start background subshell 
	unset dyn_token # Every background request should have its own token/session to avoid rate limit
	dyn_api https://api.dynect.net/REST/${type}Record/${domain}/${name}/${id} && echo $res > $cache
	dyn token kill
	dyn debug end subshell
	)& 
	while (( $(jobs -n | wc -l ) > 22 )) ; do 
		sleep .1
	done
done | cat
wait
{ echo -e "Id \t Name \t Type \t TTL \t Rdata \t Target/Value" ;
for id in $ids ; do
	cache=$dyn_domains_dir/${domain}.$id
	jq -e . $cache || return
done | dyn_record2table ; } | tabs2cols
}

function dyn_ls () {
if [[ -n $2 ]] ; then
	dyn_record_ls $@
elif [[ $1 == cache ]] ; then
	fgrep -l  '"rdata"' /dev/shm/oskars/dyn/domains/* | sort
else
	dyn_domain_ls $@
fi
}

function dyn_debug () {
[[ x$dyn_debug == xdebug ]] && echo $* 1>&2
}

function dyn_tmpfile () {
	echo $dyn_work_dir/${FUNCNAME[1]}.$BASHPID
}

function dyn () {

# export dyn_debug=off
# export dyn_use_cache=on
dyn_work_dir=/dev/shm/$USER/dyn
dyn_domains_dir=$dyn_work_dir/domains
dyn_work_dir=$dyn_work_dir/run
export dyn_domains_dir dyn_work_dir  
mkdir -p $dyn_work_dir $dyn_domains_dir

dyn_cfg

local action=$1
shift
case x$action in
	xdomain|xrecord|xcache|xtoken)
		action=${action}_$1
		shift
		dyn_$action "$@" 
		# dyn ll cache -> dyn_ll_cache
		# dyn domain rm 12345 -> dyn_domain_rm 12345
		;;
	x)
		;;
	*)
		dyn_$action "$@" 
		# dyn ll -> dyn_ll
		# dyn ll 12345 -> dyn_ll 12345
		;;
esac	
} # end function dyn
