#!/bin/bash

function read_nl () { 
readme='add new line to read -n 1 unless Enter pressed (which adds new line)'
[[ -z $REPLY ]] || echo
}

function prn_col () {
        local next
        for next in $* ; do
                echo $next
        done
} 

function sed_jq_to_ini (){
cat /dev/stdin | jq . |
egrep -v -e '^\s*}\s*$' -e '^\s*]\s*$' |
sed -r  -e '/^$/d' -e 's/^  //g' -e 's/^(\s*)"/\1/g' -e 's/": ?/=/g' -e 's/[,]$//g'
}

function json_to_ini () {
# cat  < <(  json_to_fs $testdir/ "$json" ) to hide info about bg processes
local key keys  path=$1 json="$2" value ptype type me fs=:
(( "${#@}" == 1 )) && json="$1"
me=${FUNCNAME[0]}
if [[ -z $json ]] ; then
	json=$(/bin/cat /dev/stdin)
fi
ptype=$(echo $json| jq -r type)
# jq sorts keys itself'
keys=$(echo "$json" | jq 'keys[]' 2>/dev/zero) || return 0
for key in $keys ; do
	case $ptype in
		array)
		value=$(echo $json | jq .[$key])
		;;
		*)	
		value=$(echo $json | jq .$key)
		;;
	esac
	key=$( echo $key | jq -r . )
	type=$(echo $value | jq -r type 2>/dev/zero) || continue
	local l="${#path}"	
	l=$((l + 22))
	case $type in
		array|object)
		next_path="${path} ${key}"
		# [[ x$ptype == xarray ]] && next_path="${path}${key}"
		echo "$next_path"
		$me "$next_path" "$value" &
		;;
		*)
		key=$(printf "%-${l}s" "${path} $key")
		/bin/echo "$key = $value" &
		;;
	esac
done | { wait ; sort ; }
}

function json_to_fs () {
# cat  < <(  json_to_fs $testdir/ "$json" ) to hide info about bg processes
local key keys dir=$1 json="$2" value ptype type
if [[ -z $json ]] ; then
	json=$(/bin/cat /dev/stdin)
fi
mkdir -p "$dir"
ptype=$(echo $json| jq -r type)
# jq sorts keys itself'
keys=$(echo "$json" | jq 'keys[]' 2>/dev/zero) || return 0
for key in $keys ; do
    case $ptype in
		array)
		value=$(echo $json | jq .[$key])
		;;
		*)	
		value=$(echo $json | jq .$key)
		;;
	esac
	key=$( echo $key | jq -r . )
	type=$(echo $value | jq -r type 2>/dev/zero) || continue
	case $type in
		array)
		json_to_fs "$dir/${key}[]" "$value" &
		echo "$json" >  "$dir"/.json
		;;
		object)
		json_to_fs "$dir/${key}" "$value" &
		echo "$json" >  "$dir"/.json
		;;
		*)
		(( i <= 0 )) && continue	
		/bin/echo "$value" > $dir/"$key" &
		;;
	esac
done 
wait
((i--))
}

function json_to_vars () {
local keys json="$1"
keys=$(echo "$json" | jq -r 'keys | .[]');
for key in $keys ; do
    value=$(get_key $key "$json")
	key=$value
done

}

function arr2json () {
readme="
    Converts bash array to json.
    Expects array name as the first argument
    Array should be passed as a list of items separated by newlines
    Array argument should be quoted"
local arrname=$1 array
shift
array="$@"
jq -n --arg array "$array" {${arrname}': $array  | split("\n")}'
}

function is_json () {
if [[ -f "$1" ]] ; then
    /bin/cat "$1" 2>/dev/zero
else
    echo "$1"
fi | jq -e . 2>/dev/zero |
egrep -q -m 1 '{' 2>/dev/zero # jq returns 0 on empty file. Grepping for {
}

function jqres () {
local json=$(args_to_json "$@")
jq -n "$json | { res: . }"
}

function has_key () {
local key="$1" json="$2"
if [[ -f "$json" ]] ; then
	/bin/cat "$json" | jq  -e '. | has("'$key'")' > /dev/zero
else
	jq -n -e "$json"' | . | has("'$key'")' > /dev/zero
fi
} 

function args_to_vars () {
local arg k j 
for arg in "$@" ; do
	k=${arg%%=*}
	#keys="$k $keys"
	for k in $k ; do
		export $k="${arg#*=}"
	done
done

} # end function

function args_to_json () {
local usage='
	This function accepts arguments as domain=oskar-test.com id=12 etc
	It automatically identifies the json type of value. Basically its only quoting strings.
	If unsure, embed quotes thru escaping them as name=\"123\".
	Empty arguments like name= for dnsme naked records are assumed to be empty strings. Its the same as name=\"\" '

local key value arg json
json='{}'
for arg in "$@" ; do
	key=${arg%%=*}
	value="${arg#*=}"

	local next='
		jq throws error if string is unquoted. jq -R surrounds it with quotes
		jq does not return error on empty echo. So grep on jq type '
	echo "$value" | jq -e type 2>/dev/zero | egrep -q '[a-z]' || value=$(echo $value | jq -R .)
	json=$( jq -n "$json | .$key=$value")
done  
echo $json | jq .
} # end function



function get_key () {
local key json="$2"
logic='convert json string to bash string. That is, unquote if necessary'
jq -e -n "$1" 2>/dev/zero 1>&2 && key=$(jq -n -r "$1") || key="$1"
jq -n -e "$json | .${key}"
} 

function json_dump_py () {
local py_cmd='import sys,json;
print (json.load(sys.stdin) , indent 3)'

if [[ -n "$*" ]] ; then
    echo "$*" | python -c "$py_cmd"
else
    while read line ; do
        echo $line
    done | python -c "$py_cmd"
fi
} # end function

