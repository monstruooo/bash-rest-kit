#!/bin/bash

function incap_site_id () {
[[ -z $1 ]] && return 1
local site_id domain=$1
mapfile site_id < <(incap js sites $domain | jq .site_id )

case ${#site_id[@]} in
	1)
        echo $site_id
		;;
	0)
		jq -n '{ res: { code: 1 , message: "Site '$domain' not found" , domain: "'$domain'" , source: "Oskar" } }' 1>&2
        return 1
		;;
	*)
		jq -n '{ res: { code: 2 , message: "Duplicate sites" , domain: "'$domain'" , source: "Oskar" } }' 1>&2
		return 2
		;;
esac
} # end function 

function incap_api () {
local res data="$1" api_uri="$2" api_url=https://my.incapsula.com
api_uri=${api_uri/$api_url\//}  # in case the string contains the whole url path

res=$( curl -k -S -s --data "api_id=${incap_api_id}&api_key=${incap_api_key}&${data}" $api_url/$api_uri ) ||
return 1

local res_code=$(jq -e .res <<< $res)
if (( $res_code == 0 ))
then
	echo $res
else
	echo $res | jq . 1>&2
	return $res_code
fi

echo $res | 
jq -e  'if has("site_id") and has("domain") and has("site_creation_date") then . else empty end' >/dev/zero && echo $res | incap_site2disk

}

function incap_site2disk () {
local domain site_id json
mkdir -p $sites_dir
cat /dev/stdin |
jq -c -j '.domain , " " , .site_id , " " , . , "\n"' |
while read -r domain site_id json ; do
	echo $json >  $sites_dir/${domain}_${site_id}
done
} # end function

function incap_js_sites () {  

local last_update=$sites_dir/last_update file files
if [[ ! -f $last_update ]] || find $accounts_dir/account_page-[0-9]* -newer $last_update  | egrep -q '\S+'
then
	rm -f $sites_dir/* ; touch $last_update
	jq -n '{ message: "Exploding Incapsula configuration. Can take some seconds" , source: "Oskar" }' 1>&2
	files=$(incap ll files accounts)
	[[ -z $files ]] && { echo No files found. Run incap updatedb ; return 1 ; }
	for file in $files ; do
		jq .sites[] $file | incap_site2disk &
	done 
	wait
fi
if [[ -z $1 ]] ; then
	find $sites_dir -regex '.+_[0-9]+$' -exec cat {} \;
	return
fi

incap ll files sites | egrep -e "/${1}_[0-9]+$" -e "/[^/]+_${1}$" | xargs cat
}

function incap_updatedb () {
local account_id 
local account accounts accounts2 request requests p

accounts=$(incap ll accounts |	egrep -o '^[0-9]+')
rm -f $accounts_dir/account_page-[0-9]*
accounts=" "$(echo $accounts)" " # echo and spaces to allow removing finished accounts as / $account / /
accounts2=$accounts

local page= limit=3 page_size=100 exit_code=0
export page 

while true ; do 
	local count=$(echo $accounts| wc -w)
	if (( count == 0 )) ; then
		break
	elif (( count >= limit )) ; then
		hop_pages=1
	elif (( count < limit )) ; then
		hop_pages=$((limit/count))
		echo $((limit%count)) | egrep -q ^0 || ((hop_pages++))
	fi

	local requests=
	for ((i=1;i<=hop_pages;i++)) ; do
		[[ -z $page ]] && page=0 || ((page++))
		for account in $accounts ; do
			requests="$requests $account:$page"
		done
	done

	echo Accounts: $accounts | egrep --color '.*'

	echo $requests
	for request in $requests ; do

		# The problem is unset doesn't affect the current loop thru the array
		# This break was relevant before the last changes. Leaving it in case I go to the old method
		# (( ${#accounts[@]} == 0 )) && break
		echo $accounts| wc -w | egrep -q ^0 && break
            account=${request%:*} p=${request#*:};
            printf 'Account: %-6s Page: %-3s\n' $account $p | egrep --color '.*';
            file=$accounts_dir/account_page-${account}_${p};
            incap_api "account_id=${account}&page_size=${page_size}&page_num=$p" api/prov/v1/sites/list > $file & while true; do
                local jobs;
                jobs=$(jobs -l | grep -o 'incap_api.*' | wc -l) || continue;
                (( jobs < limit )) && break;
                sleep .2;
            done;
        done;
        local logic='You need to wait for jq to finish before you can count sites';
        wait;
        for account in $accounts;
        do
            debug="Page = $page";
            file=$accounts_dir/account_page-${account}_${page};
            res=$( jq -r .res $file);
            if (( res != 0 )); then
                exit_code=$res;
            fi;
            count=$( grep -o site_id $file | wc -l );
            if (( count < page_size )); then
                echo account $account finished. The last page count is $count in $file;
                accounts=${accounts/ ${account} / };
            fi;
            if (( count == 0 )); then
                rm -f $file;
            fi;
        done;
    done;
    for account in $accounts2;
    do
        echo;
        echo $account;
        for file in $accounts_dir/account_page-${account}_[0-9];
        do
            printf '%-11s%-5s%-3s%-3s\n' $( cat $file |
                jq -r \"${file#*conf_}'" + .page + " " +(.sites|length|tostring) + " " + (.res|tostring) + " " + .res_message');
        done;
    done;
    echo;
    echo Duplicate sites:;
    jq -r .sites[].domain $accounts_dir/account_page-[0-9]* | sort -V | uniq -d | egrep --color '.*' || echo No duplicate sites detected;
    if [[ x$exit_code != x0 ]]; then
        echo -e "\nAt least one page failed with error\n" | egrep --color '.*';
        return $exit_code;
    else
        echo -e "\nSuccessfully finished downloading all Incapsula site reports\n";
    fi
}

function incap_js_accounts () {
	incap_api "page_size=100&page_num=0" https://my.incapsula.com/api/prov/v1/accounts/list
}

function incap_ll_accounts () {
	{
	echo -e "Account ID\tAccount Name" ;
	incap_js_accounts |
	jq -r '.accounts | sort_by(.account_name) | .[] |
	if "'"$*"'" == ""
	then
		.
	else
		select(.account_name=="'"$*"'" or (.account_id | tostring)=="'"$*"'")
	end |
	(.account_id|tostring) + " \t " + .account_name' ;
	} |
	tabs2cols
}

incap_site_status ()
{
    local incapsula_site_id=$1;
    incap_api "site_id=${incapsula_site_id}" api/prov/v1/sites/status
}

